import socketimport threadingimport selectimport _pickleimport sysfrom time import sleepfrom TCPConnection.TCPClient import TCPClientclass TCPServerConnection(threading.Thread):    def __init__(self, url, port, MAX_CONNECTIONS):        super().__init__()        self.address = (url, port)        self.connections = {}        self.input_queue = []        self.output_queue = []        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.server.bind(self.address)        self.server.listen(MAX_CONNECTIONS)        self.server.setblocking(False)        self.running = False    def set_name(self):        pass    def handle_inputs(self, readable):        for socket in readable:            if socket is self.server:                conn, addr = socket.accept()                self.connections[len(self.connections)] = TCPClient(                    conn,                    len(self.connections)                )                conn.send(_pickle.loads(                    self.connections[len(self.connections)]                ))            else:                data = None                try:                    data = socket.recv(1024)                    if data:                        self.input_queue.append(_pickle.loads(data))                except Exception as e:                    print(e)                    exit(0)                finally:                    del data    def get_input(self):        _data = self.input_queue        self.input_queue.clear()        return _data    def handle_outputs(self, writable, ids):        to_write = dict(zip(ids, writable))        print(to_write)        """        if self.output_queue:            data = self.output_queue.pop(0)            if 'all' in data.keys:                for socket in writable:                    socket.send(_pickle.dumps(data))            else:                pass        """    def send(self, packets, ids=None):        if ids is None:            ids = ["all"]        for packet in packets:            for id in ids:                self.output_queue.append({id: packet})    @property    def ids(self):        return [i.id for i in self.connections]    @property    def sockets(self):        return [i.socket for i in self.connections]    def run(self):        self.running = True        while self.running:            ids = self.ids            readable, writable, exceptional = select.select(                self.sockets + [self.server],                self.sockets,                [], 0            )            self.handle_inputs(readable)            self.handle_outputs(writable, ids)            print(self.input_queue)if __name__ == '__main__':    server = TCPServerConnection('localhost', 9090, 4)    server.start()    while True:        if server.input_queue:            server.get_input()        server.send([1])        sleep(0.0833333333)