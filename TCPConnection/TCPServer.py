import socketimport threadingimport selectimport _pickleimport sysimport pygamefrom time import sleepclass TCPServerConnection(threading.Thread):    def __init__(self, url, port, MAX_CONNECTIONS):        super().__init__()        self.address = (url, port)        self.connections = {}        self.input_queue = []        self.output_queue = {}        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.server.bind(self.address)        self.server.listen(MAX_CONNECTIONS)        self.server.setblocking(False)        self.running = False    def handle_inputs(self, readable):        for id in readable:            try:                data = readable[id].recv(1024)                if data:                    self.input_queue.append([id, _pickle.loads(data)])            except Exception as e:                print(e)                exit(0)    def get_input(self):        data = self.input_queue        self.input_queue = []        return data    def handle_outputs(self, writable):        for id in self.output_queue:            if self.output_queue[id]:                data = self.output_queue.pop(0)                writable[id].send(_pickle.dumps(data))    def send_all(self, packets):        for key in self.connections:            self.connections[key].append(packets)    def send(self, packets, id):        try:            self.output_queue[id].append(packets)        except KeyError:            return False        finally:            return True    @property    def ids(self):        return self.connections.keys()    def stop(self):        self.running = False    @property    def sockets(self):        return [self.connections[key] for key in self.connections]    def clear_resource(self, resource):        keys_list = self.connections.keys()        for i in range(len(keys_list)):            if self.connections[keys_list[i]] is resource:                del self.connections[keys_list[i]]                del self.input_queue[keys_list[i]]    def new_connection(self, conn):        self.output_queue[len(self.connections)] = []        self.connections[len(self.connections)] = conn    def clear_input(self):        self.input_queue.clear()    def run(self):        self.running = True        while self.running:            ids = self.ids            readable, writable, exceptional = select.select(                self.sockets + [self.server],                self.sockets,                [], 0            )            if self.server in readable:                conn, addr = self.server.accept()                self.new_connection(conn)                readable.remove(self.server)            self.handle_inputs(dict(zip(ids, readable)))            self.handle_outputs(dict(zip(ids, writable)))if __name__ == '__main__':    server = TCPServerConnection('localhost', 9090, 4)    server.start()    while True:        if server.input_queue:            server.get_input()        print(server.connections.keys())        pygame.time.Clock().tick(120)