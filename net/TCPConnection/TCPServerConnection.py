import copyimport socketimport threadingimport selectimport pickleclass TCPServerConnection(threading.Thread):    def __init__(self, url, port, max_conn_number, interface):        super().__init__(target=self.run)        self.address = (url, port)        '''Словарь из подключений id : socket'''        self.connections = {}        self.connections_counter = 0        '''Список из всех пакетов'''        self.input_queue = []        '''Словарь для отправки id : socket'''        self.output_queue = {}        '''Настройка сервера'''        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.server.bind(self.address)        self.server.listen(max_conn_number)        self.server.setblocking(False)        '''Работа с сервером'''        self.running = False        '''Для хуков извне'''        self.interface = interface    def handle_inputs(self, readable):        """Прием данных"""        for ID in readable.keys():            try:                data = readable[ID].recv(65536)                if data:                    self.input_queue.append([ID, pickle.loads(data)])            except OSError:                print('OSError, clearing resource {}'.format(ID))                self.on_disconnect(ID)            except pickle.UnpicklingError as e:                print(e)    def get_input(self):        """Взять данные снаружи"""        data = copy.copy(self.input_queue)        self.input_queue.clear()        return data    def handle_outputs(self, writable):        """Отсылаем всем"""        if self.output_queue:            for conn_number in writable.keys():                if self.output_queue[conn_number]:                    counter = 0                    for packet in self.output_queue[conn_number]:                        data = pickle.dumps(packet)                        # print(data)                        self.output_queue[conn_number].remove(packet)                        writable[conn_number].setblocking(True)                        writable[conn_number].send(data)                        writable[conn_number].setblocking(False)                        counter += 1                        if counter >= 1000:                            break    def push_data(self, packet):        """Для отправки всем, добавление в очередь"""        for key in self.connections:            self.output_queue[key].append(packet)    def push_data_by_number(self, packet, conn_number):        """Отправляем данные конкретному человеку, вызывается извне"""        try:            self.output_queue[conn_number].append(packet)            return True        except KeyError:            print('KeyError')            return False    @property    def sockets(self):        return [self.connections[key] for key in self.connections]    def on_disconnect(self, conn_number):        """Очищаем соединение"""        self.interface.on_disconnect(conn_number, self.connections[conn_number])        del self.connections[conn_number]        del self.output_queue[conn_number]    def on_connection(self, conn):        """При новом подключении"""        self.output_queue[self.connections_counter] = []        self.connections[self.connections_counter] = conn        '''Вызываем интерфейс'''        self.connections_counter += 1        self.interface.on_connection(self.connections_counter - 1)    def clean_input(self):        """Очистка принятых данных, сделано тольско для тестов, вызывать НЕ надо"""        self.input_queue.clear()    def stop(self):        self.running = False    def run(self):        """Вход в программу"""        self.running = True        while self.running:            '''Берем сокеты для чтения и записи'''            readable, writable, exceptional = select.select(                self.sockets + [self.server],                self.sockets,                [], 0.001            )            '''При подключении нового клиента'''            if self.server in readable:                conn, address = self.server.accept()                self.on_connection(conn)                readable.remove(self.server)            '''Основная часть цикла сервера'''            '''Перебор переделать'''            readable_dict = dict()            writable_dict = dict()            for read in readable:                for conn_id in self.connections.keys():                    if read == self.connections[conn_id]:                        readable_dict[conn_id] = read            for write in writable:                for conn_id in self.connections.keys():                    if write == self.connections[conn_id]:                        writable_dict[conn_id] = write            self.handle_inputs(readable_dict)            self.handle_outputs(writable_dict)            # clock.tick(300)