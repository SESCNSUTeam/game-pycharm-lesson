import socketimport threadingimport selectimport pickleimport sysimport pygamefrom time import sleepclass TCPServerConnection(threading.Thread):    def __init__(self, url, port, MAX_CONNECTIONS):        super().__init__()        self.address = (url, port)        self.connections = {}        self.input_queue = []        self.output_queue = {}        self.connections_counter = 0        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.server.bind(self.address)        self.server.listen(MAX_CONNECTIONS)        self.server.setblocking(False)        self.running = False    def handle_inputs(self, readable):        for id in readable:            try:                data = readable[id].recv(1024)                if data:                    self.input_queue.append([id, pickle.loads(data)])            except OSError:                print('OSError, clearing resource {}'.format(id))                self.clear_resource(id)    def get_input(self):        data = self.input_queue        self.input_queue = []        return data    def handle_outputs(self, writable):        for id in writable.keys():            if self.output_queue[id]:                self.connections[id].send(pickle.dumps(self.output_queue[id].pop(0)))    def send_all(self, packets):        for key in self.connections:            self.connections[key].append(packets)    def send(self, packets, id):        try:            self.output_queue[id].append(packets)        except KeyError:            return False        finally:            return True    @property    def ids(self):        return self.connections.keys()    @property    def sockets(self):        return [self.connections[key] for key in self.connections]    def clear_resource(self, id):        del self.connections[id]        del self.output_queue[id]    def new_connection(self, conn):        self.output_queue[self.connections_counter] = []        self.connections[self.connections_counter] = conn        self.connections_counter += 1    def clear_input(self):        self.input_queue.clear()    def stop(self):        self.running = False    def run(self):        self.running = True        while self.running:            readable, writable, exceptional = select.select(                self.sockets + [self.server],                self.sockets,                [], 0.001            )            if self.server in readable:                conn, addr = self.server.accept()                self.new_connection(conn)                readable.remove(self.server)            self.handle_inputs(dict(zip(self.ids, readable)))            self.handle_outputs(dict(zip(self.ids, writable)))if __name__ == '__main__':    server = TCPServerConnection('localhost', 9090, 4)    server.start()    while True:        if server.input_queue:            print(server.get_input())        for key in server.connections:            server.send([1], key)        pygame.time.Clock().tick(1000)